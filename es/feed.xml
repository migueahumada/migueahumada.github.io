<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://migueahumada.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://migueahumada.github.io/" rel="alternate" type="text/html" hreflang="es"/><updated>2025-05-28T18:59:09+00:00</updated><id>https://migueahumada.github.io/feed.xml</id><title type="html">Miguel Ahumada</title><subtitle>Personal website portfolio. Blog entries soon! </subtitle><entry><title type="html">How to set up the FMOD API in Xcode | by Miguel A. Ahumada | Medium</title><link href="https://migueahumada.github.io/blog/2025/how-to-set-up-the-fmod-api-in-xcode-by-miguel-a-ahumada-medium/" rel="alternate" type="text/html" title="How to set up the FMOD API in Xcode | by Miguel A. Ahumada | Medium"/><published>2025-03-06T00:00:00+00:00</published><updated>2025-03-06T00:00:00+00:00</updated><id>https://migueahumada.github.io/blog/2025/how-to-set-up-the-fmod-api-in-xcode--by-miguel-a-ahumada--medium</id><content type="html" xml:base="https://migueahumada.github.io/blog/2025/how-to-set-up-the-fmod-api-in-xcode-by-miguel-a-ahumada-medium/"><![CDATA[<p>Sign upSign inSign upSign in‚ÄìListenShareThis is a guide on how to set up the FMOD API to be used in Xcode.This is how to implement the FMOD API in XCode like (this guy) Guy does it. Love him üíöFirst download the FMOD API from this website. You‚Äôll probably need to log in. If you don‚Äôt have an account just make one. Don‚Äôt overthink it.Go to the FMOD Engine section and select the version you‚Äôll need. And select the Mac OS platform.Make a new Xcode console command project.Open the .dmg and you‚Äôll have to drag and drop the folder into your Xcode folder project.I created another folder called FMOD_API and within that folder I copied the folder that I previously downloaded. Now, this is important, please delete all the blank spaces from the folder name.If you don‚Äôt do it, you‚Äôll have problems when referencing libraries in Xcode. Idk why this happens but be careful.Open Xcode and go to the left sidebar and click the appstore icon that has the name of your project.In the new window, click in you project again.Go to the Build Settings tab, select All and Combined.Type in the search bar ‚ÄúSearch paths‚Äù, and in the section Header Search Paths, add the include folders‚Äô directory path from the FMOD API. These are .h files.You can also do this instead of typing all the directory, by using the macro $(PROJECT_DIR).Type in the search bar ‚ÄúLibrary search‚Äù, and in the section of Library search paths, add the library folders‚Äô directory path from the FMOD API. These are .dylib files.You can also do this:Go to Targets in the same window viewGo to Build Phases and then to Link Binaries With Libraries. Here you‚Äôll add the dylibs by just dragging and dropping them from the finder to Xcode.Now, go to the General tab and you‚Äôll have the libraries again in Frameworks and Libraries. Change the option called Embed to Embed &amp; Sign, for all of your libraries .Write something and it should work correctly. If an error appears just use the clean build command (SHIFT + CMD + K) and build again the project.Oh! And to add a sound, just do it like I did in the example, which means that I copied the audio file into the project folder.Nice! You‚Äôve used the FMOD API with Xcode.I like Xcode but this was complicated af.Follow if you want more stuff like this, or comment something if you have problems.Credits to Cody Claborn, Alejandro De Le√≥n Langur√© and Guy Somberg.Kind Regards,Miko üéßResources:‚Äî-Music, audio, videogames, tech and much more.HelpStatusAboutCareersPressBlogPrivacyRulesTermsText to speech</p>]]></content><author><name></name></author><summary type="html"><![CDATA[First download the FMOD API from this website. You‚Äôll probably need to log in. If you don‚Äôt have an account just make one. Don‚Äôt overthink it. I created another folder called FMOD_API and within that‚Ä¶]]></summary></entry><entry><title type="html">üîäPlay an audio file with XAudio2 | by Miguel A. Ahumada | Medium</title><link href="https://migueahumada.github.io/blog/2025/play-an-audio-file-with-xaudio2-by-miguel-a-ahumada-medium/" rel="alternate" type="text/html" title="üîäPlay an audio file with XAudio2 | by Miguel A. Ahumada | Medium"/><published>2025-03-02T00:00:00+00:00</published><updated>2025-03-02T00:00:00+00:00</updated><id>https://migueahumada.github.io/blog/2025/play-an-audio-file-with-xaudio2--by-miguel-a-ahumada--medium</id><content type="html" xml:base="https://migueahumada.github.io/blog/2025/play-an-audio-file-with-xaudio2-by-miguel-a-ahumada-medium/"><![CDATA[<p>Sign upSign inSign upSign in‚ÄìListenShareAlright, I hope that with this you can get an idea on how to play an audio file using XAudio2, which is a low level audio API used for games in Windows.You can find more tutorials in the documentation if you want to know more.There‚Äôs even a whole tutorial on how to do this but in a very Windows way, which I didn‚Äôt like that much, so I made some changes to that code.This implementation is mostly done with C++ code and some elements of OOP. There‚Äôs many ways to do this, but this is what I did.Before we get started let‚Äôs just take a moment to understand the Component Model Object (COM).The way libraries like DirectX11 and XAudio2 handle memory is with this model. You can get more information online and in the documentation, but what you need to know is that you don‚Äôt really create COM objects yourself, the system takes care of that. Actually, the process is done under the hood where a DLL somewhere in your computer handles that memory.In that way we‚Äôll only need to get reference to interfaces that will be created by COM. We‚Äôll use methods to create and release those objects.Now, let‚Äôs start coding.First we‚Äôll include a header from the XAudio2 library. You can either place it in your App.cpp, Game.cpp, main.cpp, doesn‚Äôt matter. Also add the stdio just for displaying errors.We need to initialize the COM Objects, we do that by using this function and checking the return value which is given by an HRESULT. This value type represents success codes that show if a COM function worked, or didn‚Äôt worked.Then create a pointer to a IXAudio2 .This interface is part of the COM system, therefore we need to create it using the result variable.Next thing we‚Äôll do is create a Mastering Voice, which can be understood as a voice of the audio engine.Then, let‚Äôs take advantage of the whole Object Oriented Paradigm and let‚Äôs create a class called Audio with a method to load audio files. Because this is Windows we‚Äôll use some native structs defined specifically for audio, like WAVEFORMATEXTENSIBLE and WAVEFORMATEX . We‚Äôll also need an XAUDIO2_BUFFER and a pointer to an array of bytes. The first will store a pointer to a buffer and the array will store the buffer of audio samples.Let‚Äôs include the fstream header so that we can read the audio fileCreate a handle to the file to read it in binary mode. If couldn‚Äôt be opened, return the function, if not continue and close the file.Until now everything‚Äôs cool but let‚Äôs learn about the wave file format.It‚Äôs basically a container of bytes that is interpreted as audio by the computer. Now, this is like a subformat, the real format is RIFF which is used for video, audio, images, etc.The most important thing to understand here is that the RIFF format is formed by chunks which carry information that helps the computer understand if the file is a video, audio or an image.You can see in this image that we have 1 RIFF chunk and 2 subchunks. The first chunk tells us whether the file is a wav file or not. The FMT chunk tells us properties about the audio file, and the data chunk has the plain old data in bytes. This tells us that audio files are just a bunch of byte data structured in chunks.The RIFF, FMT and DATA chunks are essential for any audio file, but there are more chunks.As you can see in this file, it starts with the RIFF chunk but later it jumps to something called JUNK chunk.If I keep looking in binary mode I can also find metadata embedded in the file such as the DAW where it was created.But this is no problem as what we mostly care from the subchunks is the Chunk ID and the Chunk Size. We can read the ID and tell the computer if the ID is the format chunk ID do certain things. But, if it‚Äôs an unknown ID, do something like skip this part of the binary file.If we look at the WAVEFORMATEXTENSIBLE, the struct defined by Windows, we can find there are more fields.We won‚Äôt need to worry about filling all variables in the struct, we‚Äôll just manipulate bytes instead of filling structures.So let‚Äôs go back to our code. And define a set of values in the preprocessor stage. As you saw in the wave file, there are values in big endian and little endian mode. Now, I won‚Äôt get into that as there are many tutorials about this topic. However, just know that endianness is a way to represent the order of bytes in the computer, and that it changes depending on the computer system where a program is executed.Now, let‚Äôs read the FMT chunk that every wave file has. We‚Äôll read every 4 bytes, and if the first four bytes are the letters RIFF, we‚Äôll continue. Same thing for the WAVE part.That was easy, now here‚Äôs the tricky part, we‚Äôll loop through the whole file looking for 4 bytes that correspond to the chunk IDs we defined as preprocessor variables.If the FMT chunk is found, we‚Äôll read the info and store it in the m_wavefile, which is a member variable of our Audio class.If the DATA chunk is found, we create an unsigned char array in the heap, with the size of the data chunk size. Then we tell the m_buffer to point to the m_pDataBuffer which contains all the audio sample data, and tell it that the size is equal to the data chunk size in the file.Finally, if there were no coincidences, the reading pointer of the file skips all the chunk and the process is repeated. By doing this we skip chunks we don‚Äôt need.Finally we just add a flag to the m_buffer.The final implementation looks like thisDon‚Äôt forget that we allocated memory for the m_pDataBuffer, so we need to free it in the destructor.Now, let‚Äôs go back to our main and do these few steps. Create an audio object, along with one more interface called IXAudio2SourceVoice .Then, you will need to create a Source Voice, submit the source buffer and use the start method to play the audio buffer. We‚Äôll also need to do a reinterpret cast in the CreateSourceVoice method because it needs a WAVEFORMATEX. This is easy because the WAVEFORMATEXTENSIBLE struct can be easily interpreted by Windows as a WAVEFORMATEX.All that‚Äôs left to do is set a sleep timer to let the audio play and destroy the voice and the XAudio2 interface when closing the app.Hope you enjoy this short tutorial, and if you have any suggestions let me know in the comments please. Also, tell me if it worked for you or for what project would you like to implement something like this.‚Äî-Music, audio, videogames, tech and much more.HelpStatusAboutCareersPressBlogPrivacyRulesTermsText to speech</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Alright, I hope that with this you can get an idea on how to play an audio file using XAudio2, which is a low level audio API used for games in Windows.]]></summary></entry><entry><title type="html">üîâ How to set up the FMOD API in Visual Studio | by Miguel A. Ahumada | Medium</title><link href="https://migueahumada.github.io/blog/2024/how-to-set-up-the-fmod-api-in-visual-studio-by-miguel-a-ahumada-medium/" rel="alternate" type="text/html" title="üîâ How to set up the FMOD API in Visual Studio | by Miguel A. Ahumada | Medium"/><published>2024-03-09T00:00:00+00:00</published><updated>2024-03-09T00:00:00+00:00</updated><id>https://migueahumada.github.io/blog/2024/-how-to-set-up-the-fmod-api-in-visual-studio--by-miguel-a-ahumada--medium</id><content type="html" xml:base="https://migueahumada.github.io/blog/2024/how-to-set-up-the-fmod-api-in-visual-studio-by-miguel-a-ahumada-medium/"><![CDATA[<p>Sign upSign inSign upSign in‚ÄìListenShareIt took me at least an hour to complete all of this, but hopefully you can do it faster than I did.So, here‚Äôs a guide on how to set up the FMOD API in Visual Studio 2022. It also works for VS 2019.I have a similar tutorial, but for Xcode. So, if you‚Äôre looking for that, just click here.This project was also inspired by Guy Somberg‚Äôs talk at the CPP Conference 2017.Go to this site to download the FMOD API. Sign in, and then click in the FMOD engine to find your chosen version. I used 2.02.12 for Windows, not Windows 10 UWP.Open Visual Studio and create a new project. Make sure you create a Console App C++ project.Click on the FMOD API installer and install it in your VS project directory. Rename the folder if you want. I changed mine to FMOD_API.Open the .slnfile (the solution). Build it once so that it works with the default configuration. Errors shouldn‚Äôt appear at this moment. You can either build it in Release or in Debug mode. The build shortcut is CTRL + F5.Go to the right side bar (Solution Explorer) and right-click your application, then go to Properties at the end of the list.Change the configuration to All configurations and your chosen architecture, mine was x64.Go to Configuration Properties &gt; C/C++ &gt; General &gt; Additional Include Directories and in the text box, type the file paths of the include files from the Studio and Core FMOD API. I used the Macro $(SolutionDir) to have a relative path. By doing all of this, you‚Äôre telling VS to include the .hpp and .h files.Then go to Configuration Properties &gt; Linker &gt; General &gt; Additional Library Directories. Here, you‚Äòll need to do the same thing but for the libraries, .libfiles.Go to Configuration Properties &gt; Linker &gt; Input &gt; Additional Dependencies. Here, you‚Äôre going to use different configurations for the Release and Debug builds, so bear with me.For the Debug configuration, type these dependencies, which are .lib files.For the Release configuration, type these dependencies, which are also .libfiles.We‚Äôre almost there.Change the configuration to All Configurations and go to Configuration Properties &gt; Build Events &gt; Post-Build Events &gt; Command line. Type this command to copy the dynamic libraries to the output directory.An alternative to this script would be to copy the .dll files to the debug and release output directories of your project.Remember to change $(SolutionDir)FMOD\api\core\lib\x64 to your own path for the studio and the core API.Now copy this code, from the GDC talk and make sure to change the file path in System-&gt;createSound to the file path of the sound you want to play.Nice! You used the FMOD API with Visual Studio.Follow if you want more stuff like this.Credits go to Cody Claborn and Guy Somberg.Kind Regards,Miko üéßResources:‚Äî-Music, audio, videogames, tech and much more.HelpStatusAboutCareersPressBlogPrivacyRulesTermsText to speech</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Go to this site to download the FMOD API. Sign in, and then click in the FMOD engine to find your chosen version. I used 2.02.12 for Windows, not Windows 10 UWP. Click on the FMOD API installer and‚Ä¶]]></summary></entry></feed>